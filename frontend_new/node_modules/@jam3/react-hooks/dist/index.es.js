import react, { useState, useEffect, useRef, useCallback } from 'react';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var INTERSECTION_OBSERVER_CONFIG = {
  threshold: 0.0,
  triggerOnce: true,
  rootMargin: "0px"
};

function useIntersectionObserver(ref) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var rootRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isIntersecting = _useState2[0],
      setIntersecting = _useState2[1];

  var options = _objectSpread2({
    root: rootRef && rootRef.current
  }, INTERSECTION_OBSERVER_CONFIG, {}, config);

  useEffect(function () {
    var observer = new IntersectionObserver(function (entries) {
      if (options.triggerOnce) {
        if (entries[0].isIntersecting) {
          setIntersecting(true);
          observer.unobserve(ref.current);
        }
      } else {
        setIntersecting(entries[0].isIntersecting);
      }
    }, options);

    if (!ref) {
      console.warn("No target specified - use useRef() hook to pass the target value");
      return;
    }

    var current = ref.current;
    observer.observe(current);
    return function () {
      if (current) observer.unobserve(current);
    };
  }, [ref, options, setIntersecting]);
  return isIntersecting;
}

var isBrowser = typeof window !== "undefined";
function getScrollTop() {
  return isBrowser ? window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop : 0;
}

var useMousePosition = function useMousePosition() {
  var _useState = useState({
    x: 0,
    y: 0
  }),
      _useState2 = _slicedToArray(_useState, 2),
      position = _useState2[0],
      setPosition = _useState2[1];

  useEffect(function () {
    var setFromEvent = function setFromEvent(e) {
      return setPosition({
        x: e.clientX,
        y: e.clientY
      });
    };

    isBrowser && window.addEventListener("mousemove", setFromEvent);
    return function () {
      isBrowser && window.removeEventListener("mousemove", setFromEvent);
    };
  }, [setPosition]);
  return position;
};

var useOnHover = function useOnHover(ref, inCallback, outCallback) {
  useEffect(function () {
    if (isBrowser) {
      ref.current.addEventListener("mouseenter", inCallback);
      ref.current.addEventListener("mouseleave", outCallback);
    }

    return function () {
      if (isBrowser) {
        window.removeEventListener("mousemove", inCallback);
        window.removeEventListener("mousemove", outCallback);
      }
    };
  }, []);
};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var callback = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

function useDebouncedCallback(callback, delay, options) {
    if (options === void 0) { options = {}; }
    var maxWait = options.maxWait;
    var maxWaitHandler = react.useRef(null);
    var maxWaitArgs = react.useRef([]);
    var leading = options.leading;
    var wasLeadingCalled = react.useRef(false);
    var functionTimeoutHandler = react.useRef(null);
    var isComponentUnmounted = react.useRef(false);
    var debouncedFunction = callback;
    var cancelDebouncedCallback = react.useCallback(function () {
        clearTimeout(functionTimeoutHandler.current);
        clearTimeout(maxWaitHandler.current);
        maxWaitHandler.current = null;
        maxWaitArgs.current = [];
        functionTimeoutHandler.current = null;
        wasLeadingCalled.current = false;
    }, []);
    react.useEffect(function () { return function () {
        // we use flag, as we allow to call callPending outside the hook
        isComponentUnmounted.current = true;
    }; }, []);
    var debouncedCallback = react.useCallback(function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        maxWaitArgs.current = args;
        clearTimeout(functionTimeoutHandler.current);
        if (!functionTimeoutHandler.current && leading && !wasLeadingCalled.current) {
            debouncedFunction.apply(void 0, args);
            wasLeadingCalled.current = true;
            return;
        }
        functionTimeoutHandler.current = setTimeout(function () {
            cancelDebouncedCallback();
            if (!isComponentUnmounted.current) {
                debouncedFunction.apply(void 0, args);
            }
        }, delay);
        if (maxWait && !maxWaitHandler.current) {
            maxWaitHandler.current = setTimeout(function () {
                var args = maxWaitArgs.current;
                cancelDebouncedCallback();
                if (!isComponentUnmounted.current) {
                    debouncedFunction.apply(null, args);
                }
            }, maxWait);
        }
    }, [debouncedFunction, maxWait, delay, cancelDebouncedCallback, leading]);
    var callPending = function () {
        // Call pending callback only if we have anything in our queue
        if (!functionTimeoutHandler.current) {
            return;
        }
        debouncedFunction.apply(null, maxWaitArgs.current);
        cancelDebouncedCallback();
    };
    // At the moment, we use 3 args array so that we save backward compatibility
    return [debouncedCallback, cancelDebouncedCallback, callPending];
}
exports.default = useDebouncedCallback;
});

unwrapExports(callback);

var cache = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });


function useDebounce(value, delay, options) {
    var _a = react.useState(value), state = _a[0], dispatch = _a[1];
    var _b = callback.default(react.useCallback(function (value) { return dispatch(value); }, []), delay, options), callback$1 = _b[0], cancel = _b[1];
    var previousValue = react.useRef(value);
    react.useEffect(function () {
        // We need to use this condition otherwise we will run debounce timer for the first render (including maxWait option)
        if (previousValue.current !== value) {
            callback$1(value);
            previousValue.current = value;
        }
    }, [value, callback$1]);
    return [state, cancel];
}
exports.default = useDebounce;
});

unwrapExports(cache);

var lib = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

exports.useDebounce = cache.default;

exports.useDebouncedCallback = callback.default;
});

unwrapExports(lib);
var lib_1 = lib.useDebounce;
var lib_2 = lib.useDebouncedCallback;

var SCROLL_UP = "up";
var SCROLL_DOWN = "down";
var TOP = "top";
var defaultThrottle = 100;
function useScrollDirection() {
  var throttle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultThrottle;
  var lastScrollY = useRef(getScrollTop());

  var _useState = useState(TOP),
      _useState2 = _slicedToArray(_useState, 2),
      scrollDir = _useState2[0],
      setScrollDir = _useState2[1];

  var _useDebouncedCallback = lib_2(useCallback(function () {
    var scrollY = getScrollTop();
    setScrollDir(scrollY === 0 ? TOP : scrollY > lastScrollY.current ? SCROLL_DOWN : SCROLL_UP);
    lastScrollY.current = scrollY;
  }, [setScrollDir]), throttle, {
    maxWait: throttle
  }),
      _useDebouncedCallback2 = _slicedToArray(_useDebouncedCallback, 1),
      handleScroll = _useDebouncedCallback2[0];

  useEffect(function () {
    if (isBrowser) {
      window.addEventListener("scroll", handleScroll);
      return function () {
        return window.removeEventListener("scroll", handleScroll);
      };
    }
  }, [handleScroll]);
  return scrollDir;
}

var useScrollProgress = function useScrollProgress() {
  var _useState = useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      progress = _useState2[0],
      setProgress = _useState2[1];

  useEffect(function () {
    var updateHeight = function updateHeight() {
      var math = 100 * window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
      setProgress(math.toFixed(0));
    };

    isBrowser && window.addEventListener("scroll", updateHeight);
    return function () {
      isBrowser && window.removeEventListener("scroll", updateHeight);
    };
  }, [setProgress]);
  return progress;
};

function useScrollToTop() {
  var hasScrolled = useRef(false);

  if (!hasScrolled.current) {
    hasScrolled.current = true;
    if (isBrowser) window.scrollTo(0, 0);
  }
}

function getSize() {
  return {
    innerHeight: isBrowser ? window.innerHeight : 0,
    innerWidth: isBrowser ? window.innerWidth : 0
  };
}

function useWindowSize() {
  var debounce = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;

  var _useState = useState(getSize()),
      _useState2 = _slicedToArray(_useState, 2),
      windowSize = _useState2[0],
      setWindowSize = _useState2[1];

  var _useDebouncedCallback = lib_2(useCallback(function () {
    setWindowSize(getSize());
  }, [setWindowSize]), debounce),
      _useDebouncedCallback2 = _slicedToArray(_useDebouncedCallback, 1),
      handleResize = _useDebouncedCallback2[0];

  useEffect(function () {
    window.addEventListener("resize", handleResize);
    return function () {
      window.removeEventListener("resize", handleResize);
    };
  }, [handleResize]);
  return windowSize;
}

export { useIntersectionObserver, useMousePosition, useOnHover, useScrollDirection, useScrollProgress, useScrollToTop, useWindowSize };
//# sourceMappingURL=index.es.js.map
